## Java 内存模型

## Jvm命令行参数
- **标准选项 以 - 为前缀  -help 可以看到所有的标准选项**
- **非标准选项 以 -X 为前准 不强制要求所有jvm都实现 -X 参数可以看到 所有的非标准选项**
- **非稳定选项 以 -XX 为前缀 主要给开发者调试使用 在后续版本可能会废除，带有布尔标记的非稳定选项，选项前的+或-表示true和false，用于开启对应的特性或者使用默认值**

### GC 优化配置
配置  |  描述
--|--
-Xms  |  初始化堆内存大小
-Xmx  |  堆内存最大值
-Xmn  |  新生代大小
-XX:PermSize  |  初始化永久代大小
-XX:MaxPermSize  |  永久代最大容量

GC 类型设置
配置 |  描述
--|--
-XX:+UseSerialGC  |串行垃圾回收器
-XX:+UseParallelGC  |并行垃圾回收器
-XX:+UseConcMarkSweepGC  |并发标记扫描垃圾回收器
-XX:ParallelCMSThreads=  |并发标记扫描垃圾回收器 = 为使用的线程数量
-XX:+UseG1GC  |G1 垃圾回收器
## GC collector 垃圾收集器
![](https://i.loli.net/2018/03/14/5aa890c77bafd.png)
以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用

大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC；
关于 Minor GC 和 Full GC：
- Minor GC 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快
- Full GC 发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多

对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC，而 Full GC 则相对复杂，有以下条件：
- 调用 System.gc() 此方法的调用是建议 JVM 进行 Full GC，虽然只是建议而非一定
- 老年代空间不足
- 空间分配担保失败
- JDK 1.7 及以前的永久代空间不足
- Concurrent Mode Failure

### 1.新生代 young generation
#### 1.1 Serial 收集器
![](https://i.loli.net/2018/03/14/5aa89137cfc8c.png)
它是单线程的收集器，不仅意味着只会使用一个线程进行垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停所有其他工作线程，往往造成过长的等待时间
它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率

       复制算法
       最简单的collector，只有一个thread负责GC 并且，在执行GC的时候，会暂停整个程序（所谓的“stop-the-world”)
  对应日志
```
    0.844: [GC 0.844: [DefNew: 17472K->2176K(19648K), 0.0188339 secs] 17472K->2375K(63360K), 0.0189186 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
```

#### 1.2 Parallel Scavenge 收集器

是并行的多线程收集器。

其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。自适应调节策略也是它与 ParNew 收集器的一个重要区别

    复制算法
    使用multi-thread来处理GC，当然，在执行的时候，仍然会“stop-the-world”，好处在于，暂停的时间更短
    对应日志:
    2017-09-18T15:51:48.174-0800: 15567.067: [GC (Allocation Failure) [PSYoungGen: 270528K->672K(259584K)] 343867K->74043K(370688K), 0.0614831 secs] [Times: user=


#### 1.3 ParNew 收集器
![](https://i.loli.net/2018/03/14/5aa891abb935a.png)
它是 Serial 收集器的多线程版本
是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作
默认开始的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数

    基本上和Parallel Scavenge非常相似，唯一的区别，在于它做了强化能够和CMS一起使用
    对应日志：
    0.834: [GC 0.834: [ParNew: 13184K->1600K(14784K), 0.0092203 secs] 13184K->1921K(63936K), 0.0093401 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]


### 2.老生代 tenured generation

#### 2.1 Serial Old 收集器

    单线程 采用 mark-sweep-compact （标记-压缩）回收方法


#### 2.2 Parallel Old 收集器
是 Parallel Scavenge 收集器的老年代版本
在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器

    多线程 采用 mark-sweep-compact （标记-压缩）回收方法

#### 2.3 CMS

    全称“concurrent-mark-sweep”（并发标记清除） ，它是最并发，暂停时间最低的collector，之所以称为concurrent，是因为它在执行GC任务的时候，GC thread是和application thread一起工作的，基本上不需要暂停application thread 新生代一般配合 ParNew
    特点：尽可能降低停顿 会影响系统整体吞吐量和性能 清理不彻底
    特点：`并发收集`、`低停顿`

    主要过程
    1.初始标记（会产生全局停顿） 标记根可以直接关联到的对象
    2.并发标记（和用户线程一起） 主要标记过程，标记全部对象
    3.重新标记 （会产生全局停顿）由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正
    4.并发清除（和用户线程一起） 基于标记结果，直接清理对象
    对应日志
    1.666: [CMS-concurrent-mark-start]
    1.699: [CMS-concurrent-mark: 0.033/0.033 secs] [Times: user=0.25 sys=0.00, real=0.03 secs]
    1.699: [CMS-concurrent-preclean-start]
    1.700: [CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    1.700: [GC[YG occupancy: 1837 K (14784 K)]1.700: [Rescan (parallel) , 0.0009330 secs]1.701: [weak refs processing, 0.0000180 secs] [1 CMS-remark: 28122K(49152K)] 29959K(63936K), 0.0010248 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    1.702: [CMS-concurrent-sweep-start]
    1.739: [CMS-concurrent-sweep: 0.035/0.037 secs] [Times: user=0.11 sys=0.02, real=0.05 secs]
    1.739: [CMS-concurrent-reset-start]

    这里就能很明显的看出，为什么CMS要使用标记清除而不是标记压缩，如果使用标记压缩，需要多对象的内存位置进行改变，这样程序就很难继续执行。但是标记清除会产生大量内存碎片，不利于内存分配

缺点：
- 对 CPU 资源敏感。CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4，当 CPU 不足 4 个时，CMS 对用户程序的影响就可能变得很大，如果本来 CPU 负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了 50%，其实也让人无法接受。并且低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率变低
- 无法处理浮动垃圾。由于并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法在当次收集中处理掉它们，只好留到下一次 GC 时再清理掉，这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此它不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。可以使用 -XX:CMSInitiatingOccupancyFraction 的值来改变触发收集器工作的内存占用百分比，JDK 1.5 默认设置下该值为 68，也就是当老年代使用了 68% 的空间之后会触发收集器工作。如果该值设置的太高，导致浮动垃圾无法保存，那么就会出现 Concurrent Mode Failure，此时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集
- 标记-清除算法导致的空间碎片，给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前出发一次 Full GC



### 3 配套使用

在设定JVM参数的时候，很少有人去分别制定young generation和tenured generation的collector，而是提供了几套选择方案：

**-XX:+UseSerialGC**

    相当于”Serial” + “SerialOld”，这个方案直观上就应该是性能最差的

**-XX:+UseParallelGC**

    相当于” Parallel Scavenge” + “SerialOld”，也就是说，在young generation中是多线程处理，但是在tenured generation中是单线程

**UseParallelOldGC**

    相当于” Parallel Scavenge” + “ParallelOld”，都是多线程并行处理

**-XX:+UseConcMarkSweepGC**

    相当于"ParNew" + "CMS" + "Serial Old"，即在young generation中采用ParNew，多线程处理；在tenured generation中使用CMS，
    以求得到最低的暂停时间，但是，采用CMS有可能出现”Concurrent Mode Failure”（这个后面再说），
    如果出现了，就只能采用”SerialOld”模式了

#### 七种垃圾收集器的比较
收集器  |串行、并行 or 并发   |新生代 / 老年代   |算法   |  目标 |  适用场景
--|---|---|---|---|--
Serial  |串行   |新生代   |复制算法   |响应速度优先   |单 CPU 环境下的 Client 模式
Serial Old  |串行   |老年代   |标记-整理   |响应速度优先   |单 CPU 环境下的 Client 模式、CMS 的后备预案
ParNew  |并行   |新生代   |复制算法   |响应速度优先   |多 CPU 环境时在 Server 模式下与 CMS 配合
Parallel Scavenge  |并行   |新生代   |复制算法   |吞吐量优先   |在后台运算而不需要太多交互的任务
Parallel Old  | 并行  | 老年代  | 标记-整理  | 吞吐量优先  |在后台运算而不需要太多交互的任务
CMS  | 并发  | 老年代  | 标记-清除  | 响应速度优先  |集中在互联网站或 B/S 系统服务端上的 Java 应用
G1  | 并发  | both  |标记-整理 + 复制算法   | 响应速度优先  |面向服务端应用，将来替换 CMS


### 4 G1和安全点

**G1收集器**
G1（Garbage-First）收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot 开发团队赋予它的使命是（在比较长期的）未来可以替换掉 JDK 1.5 中发布的 CMS 收集器

> G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器，使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合

具备如下特点：
- 并行与并发：能充分利用多 CPU 环境下的硬件优势，使用多个 CPU 来缩短停顿时间
- 分代收集：分代概念依然得以保留，虽然它不需要其它收集器配合就能独立管理整个 GC 堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次 GC 的旧对象来获取更好的收集效果
- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片
- 可预测的停顿：这是它相对 CMS 的一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了

**安全点**

> 安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点

    接下来的问题就在于，如何让程序在需要GC时都跑到安全点上停顿下来，大多数JVM的实现都是采用主动式中断的思想。

> 主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方


### 执行模式

    Just In Time，简称JIT，可以理解为动态编译。运行时才可以确定具体要编译的代码
    还有一种，叫Ahead Of Time，简称AOT，可以理解为静态编译，即编译器在编译阶段就确定所有的运行代码

    Android在5.0以后彻底抛弃Dalvik转投ART，最大的一点变化就是把JIT换成了AOT。原来的APP在每次打开时虚拟机才会编译，每次打开都编译一次，所以响应速度慢就是这个原因。而ART则是在安装时，编译器就已经将所有的二进制代码编译完成，并储存在本地。这样每次打开直接读取本地二进制文件就可以了，所以存储空间占的更大，用空间换时间

## 四种引用 --  强引用 软引用 弱引用 虚引用

**强引用**

>只要某个对象有强引用与之关联，JVM必定不会回收这个对象，即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象

**软引用（SoftReference)**

>软引用是用来描述一些有用但并不是必需的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中

**弱引用（WeakReference)**

>弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示

__ThreadLocal__的实现中使用WeakReference

**虚引用（PhantomReference）**

>虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

__虚引用主要用来跟踪对象被垃圾回收器回收的活动__
>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中
