
本文主要摘抄自 http://www.cnblogs.com/xiaohuochai/p/5699739.html

#### 编译
以var a = 2;为例，说明javascript的内部编译过程，主要包括以下三步：
- **分词(tokenizing)** 把由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元(token)
- **解析(parsing)** 把词法单元流数组转换成一个由元素逐级嵌套所组成的代表程序语法结构的树，这个树被称为“抽象语法树” (Abstract Syntax Tree, AST)
- **代码生成** 将AST转换为可执行代码的过程被称为代码生成

#### 执行

- 引擎运行时会首先查询作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量
- 引擎运行时会首先查询作用域，在当前的作用域集合中是否存在一个叫作a的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量

#### 查询

在引擎执行的第一步操作中，对变量a进行了查询，这种查询叫做LHS查询。实际上，引擎查询共分为两种：LHS查询和RHS查询
从字面意思去理解，当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询

#### 嵌套

在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止

#### 异常

为什么区分LHS和RHS是一件重要的事情？因为在变量还没有声明（在任何作用域中都无法找到变量）的情况下，这两种查询的行为不一样
- RHS 如果RHS查询失败，引擎会抛出ReferenceError(引用错误)异常
- RHS 如果RHS查询找到了一个变量，但尝试对变量的值进行不合理操作，比如对一个非函数类型值进行函数调用，或者引用null或undefined中的属性，引擎会抛出另外一种类型异常：TypeError(类型错误)异常
- LHS 当引擎执行LHS查询时，如果无法找到变量，全局作用域会创建一个具有该名称的变量，并将其返还给引擎
- LHS 如果在严格模式中LHS查询失败时，并不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的ReferenceError异常

### 词法作用域和动态作用域

#### 词法作用域

编译器的第一个工作阶段叫作分词，就是把由字符组成的字符串分解成词法单元。这个概念是理解词法作用域的基础

简单地说，词法作用域就是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变

**关系**
无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定
![作用域](https://i.loli.net/2018/01/19/5a6198c7a5f70.png)

**查找**
从最内部的作用域 向外查找
**遮蔽**
多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”，内部的标识符“遮蔽”了外部的标识符

#### 动态作用域

javascript使用的是词法作用域，它最重要的特征是它的定义过程发生在代码的书写阶段

动态作用域并不关心函数和作用域是如何声明以及在任何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套
```javascript
var a = 2;
function foo() {
    console.log( a );
}
function bar() {
    var a = 3;
    foo();
}
bar();
```

### 声明提升

#### 变量声明提升
```javascript
a = 2 ;
var a;
console.log( a );
```
#### 函数声明提升

```javascript
foo();
function foo(){
    console.log(1);//1
}
```
但函数表达式无法提升
```javascript
foo();
var foo = function(){
    console.log(1);//TypeError: foo is not a function
}

```

#### 函数覆盖
函数声明和变量声明都会被提升。但是，函数声明会覆盖变量声明
```javascript
var a;
function a(){}
console.log(a);//'function a(){}'

```

### 块作用域

```javascript
for (var i= 0; i<10; i++) {
    console.log(i);
}
```
上面这段是很熟悉的循环代码，通常是因为只想在for循环内部的上下文中使用变量i，但实际上i可以在全局作用域中访问，污染了整个作用域
**let**
ES6改变了现状，引入了新的let关键字，提供了除var以外的另一种变量声明方式。let关键字可以将变量绑定到所在的任意作用域中(通常是{...}内部)，实现块作用域
```javascript
{
  let i = 1;
};
console.log(i);//ReferenceError: i is not defined
```
**const**
除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误
