#### 关于闭包

每次定义一个函数，都会产生一个**作用域链（scope chain）**。当JavaScript寻找变量varible时（这个过程称为变量解析），总会优先在当前作用域链的第一个对象中查找属性varible ，如果找到，则直接使用这个属性；否则，继续查找下一个对象的是否存在这个属性；这个过程会持续直至找到这个属性或者最终未找到引发错误为止。

**scopechain是个有顺序的集合对象**

看个简单版的例子：

``` JavaScript
(function(){
    var hello="hello,world";
    function welcome(hi){
        alert(hi);        //解析到作用域链的第一个对象的属性
        alert(hello);    //解析到作用域链的第二个对象的属性
    }
    welcome("It's easy");
})();
```

运行结果很简单，一个弹窗It's easy.一个弹窗hello,world
分析过程如下：
对于函数welcome()，定义welcome的时候会产生一个作用域链对象，为了表示方便，记作scopechain。scopechain是个有顺序的集合对象
- scopechain的第一个对象：为了方便表示记作sc1， sc1有若干属性，引用本函数的参数和局部变量，如sc1.hi
- scopechain的第二个对象：为了方便表示记作sc2，sc2有若干属性，引用外层函数的参数和局部变量，如sc2.hello
- ...
- scopechain的最后一个对象：为了方便表示记作scn，scn引用的全局的执行环境对象，也就是window对象！，如scn.eval()

这里之所以可以弹出hello,world，原因就是变量解析时在welcome函数作用域链的第一个对象上找不到hello属性，然后就去第二个对象上找去了（结果还真找到了）

所以，JavaScript中的所谓的高大上的**闭包其实很简单，根本上还是变量解析。而之所以可以实现，还是因为变量解析会在作用域链中依次寻找对应属性的导致的**

**一句话解释：闭包就是跨作用域访问变量！**
函数内访问全局变量大家都知道，那因为全局变量的作用域已经覆盖到函数：
```JavaScript
var age=18;
function a()
{
    alert(age)
}
```
当全局变量访问函数内局部变量时，因为局部变量作用域只在函数内，所以无法访问。但通过闭包就可以让全局变量跨作用域访问局部变量
```JavaScript
var a=function()
 {
     var age=18;
     return function(){return age; }
 };
 var b=a()();

```

**简单粗暴的理解，最终极的用途就是把函数当类用，说是闭包，其实也可以叫封装**

**上面两个都是摘抄自知乎回答**

#### 为什么要使用闭包

那么闭包既然是为了共享某个变量，那么为什么不搞个全局变量？如果是个小项目，就那么几个全局变量，还真不需要什么闭包。但是如果是大的项目，很多需要共享的变量都弄成全局的话，那么起名字都非常头疼，代码多了都不知道这个变量干嘛的了，甚至出现多个函数修改一个变量导致混乱

因此我们需要模块化，变量私有化，这个时候可以用到闭包，让私有变量驻留在内存中，无关的模块无法访问。太多的闭包也会带来问题，因为太多的变量没法回收会占用更多的内存，因此需要我们手动释放闭包产生的变量，例如上面我们使用var c = a()引用了变量i，不需要的时候要让c = null或者其他值，释放函数a的引用让函数a里面的所有变量回收

在全局window作用域下运行下面代码
```
var foo = 0; // 定义变量 foo
// 为这个按钮注册一个单击事件
document.getElementById('btn').addEventListener('click', function bar(e) {
   console.log(++foo);
});
```

那么，上面例子能形成闭包吗？是的，这就是闭包。上面的函数bar 和变量foo都定义在同一个环境下，但是注意函数bar仅仅是定义了并赋值给addEventListener函数注册事件，但是函数bar此时还未运行，它要到按钮被点击时才会被浏览器运行，这意味着运行时的环境跟定义时的环境已经不一样了，但是函数bar依然会带着它作用域链中的变量foo

但是上面的闭包有用吗？没有用，因为这是全局作用域，变量foo在任何时候都能被直接访问，因此你感受不到这是通过闭包访问的。

那么对上面代码改进下，把它放到一个函数里面，然后立即运行这个函数，就像这样：
```
// 定义一个函数，里面还是刚才的代码
function addEvent() {
    var foo = 0;
    document.getElementById('btn').addEventListener('click', function (e) {
        console.log(++foo);
    });
}
// 然后执行这个函数，你也可以使用立即执行函数表达式IIFE
addEvent();
```
然后再不断点击按钮，这个时候会和刚才那样不断输出递增的数字，并且，你已经无法访问到变量foo了

还是上面提到的点，假如没有事件程序引用了变量内部变量foo，那么在函数addEvent运行完之后变量foo就会被回收了。 所以，这是个有用的闭包，在实际使用中，这种形式非常常见。


**通过在下级作用域引用的方式防止上级作用域中定义的变量被gc回收**
