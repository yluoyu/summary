### 图说mysql查询执行流程
![图说mysql查询执行流程](https://i.loli.net/2018/02/28/5a961706cfdbe.png)

先整体了解下SQL查询的基本执行过程
>1）应用通过MySQL API把查询命令发送给MySQL服务器，然后被解析
2）检查权限、MySQL optimizer进行优化，经过解析和优化后的查询命令被编译为CPU可运行的二进制形式的查询计划（query
plan），并可以被缓存
3）如果存在索引，那么先扫描索引，如果数据被索引覆盖，那么不需要额外的查找，如果不是，根据索引查找和读取对应的记录
4）如果有关联查询，查询次序是扫描第一张表找到满足条件的记录，按照第一张表和第二张表的关联键值，扫描第二张表查找满足条件的记录，按此顺序循环
5）输出查询结果，并记录binary logs

查询优化几个方向
- 尽量避免全文扫描，给相应字段增加索引，应用索引来查询
- 查询重写，等价转换（谓词、子查询、连接查询）
- 删除内容重复不必要的语句，精简语句
- 整合重复执行的语句
- 缓存查询结果

网上找的一个索引使用口诀
```
全值匹配我最爱，最左前缀要遵守
带头大哥不能死，中间兄弟不能断
索引列上少计算，范围之后全失效
like百分写最右，覆盖索引不写星
不等空值还有or，索引失效要少用
```
这里说下覆盖索引
如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作

select 少用*的理由：
- 覆盖索引的使用
- 如果有排序的话 有额外开销
- 网络传输消耗大


#### 最左前缀原则
最左前缀原则指的的是在sql where 子句中一些条件或表达式中出现的列的顺序要保持和多索引的一致或以多列索引顺序出现，只要 出现非顺序出现、断层都无法利用到多列索引
举例说明：上面给出一个多列索引(username,password,last_login)，当三列在where中出现的顺序如(username,password,last_login)、 (username,password)、(username)才能用到索引，如下面几个顺序(password,last_login)、(passwrod)、(last_login)---这三者不 从username开始，(username,last_login)---断层，少了password，都无法利用到索引。因为B+tree多列索引保存的顺序是按照索引创 建的顺序，检索索引时按照此顺序检索

#### 使用索引进行排序
MySQL中，有两种方式生成有序结果集：一是使用filesort，二是按索引顺序扫描

利用索引进行排序操作是非常快的，而且可以利用同一索引同时进 行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序，如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引，其它情况都会使用filesort

当MySQL不能使用索引进行排序时，就会利用自己的排序算法(快速排序算法)在内存(sort buffer)中对数据进行排序，如果内存装载不下，它会将磁盘上的数据进行分块，再对各个数据块进行排序，然后将各个块合并成有序的结果集（实际上就是外排序）

对于filesort，MySQL有两种排序算法
**一、两遍扫描算法(Two passes)**
实现方式是先将须要排序的字段和可以直接定位到相关行数据的指针信息取出，然后在设定的内存（通过参数sort_buffer_size设定）中进行排序，完成排序之后再次通过行指针信息取出所需的Columns
注：该算法是4.1之前采用的算法，它需要两次访问数据，尤其是第二次读取操作会导致大量的随机I/O操作。另一方面，内存开销较小
**二、 一次扫描算法(single pass)**
该算法一次性将所需的Columns全部取出，在内存中排序后直接将结果输出
注： 从 MySQL 4.1 版本开始使用该算法。它减少了I/O的次数，效率较高，但是内存开销也较大。如果我们将并不需要的Columns也取出来，就会极大地浪费排序过程所需要 的内存。在 MySQL 4.1 之后的版本中，可以通过设置 max_length_for_sort_data 参数来控制 MySQL 选择第一种排序算法还是第二种。当取出的所有大字段总大小大于 max_length_for_sort_data 的设置时，MySQL 就会选择使用第一种排序算法，反之，则会选择第二种。为了尽可能地提高排序性能，我们自然更希望使用第二种排序算法，所以在 **Query 中仅仅取出需要的 Columns 是非常有必要的**

当对连接操作进行排序时，如果ORDER BY仅仅引用第一个表的列，MySQL对该表进行filesort操作，然后进行连接处理，此时，EXPLAIN输出“Using filesort”；否则，MySQL必须将查询的结果集生成一个临时表，在连接完成之后进行filesort操作，此时，EXPLAIN输出 “Using temporary;Using filesort”


#### 子查询优化
在from中为非相关子查询，可以上拉子查询到父层。在多表连接查询考虑连接代价再选择
查询优化器对子查询一般采用嵌套执行的方式，即对父查询中的每一行，都执行一次子查询，这样子查询会执行很多次。这种执行方式效率很低
子查询转化为连接查询优点：
- 子查询不用执行很多次
- 优化器可以根据信息来选择不同的方法和连接顺序
- 子查询的连接条件，过滤条件变成父查询的筛选条件，以提高效率

select * from t1 (select*from tab where id>10) as t2 where t1.age>10 and t2.age<25;
select*from t1,tab as t2 where t1.age>10 and t2.age<25 and t2.id>10;
`注`：子查询展开只能展开简单的查询，若子查询含有聚集函数、GROUP BY、DISTINCT，则不能上拉

#### 等价谓词重写
- BETWEEEN AND改写为 >= 、<=之类的。实测：十万条数据，重写前后时间，1.45s、0.06s

#### 条件化简与优化
- 将where、having（不存在groupby和聚集函数时）、join-on条件能合并的尽量合并
- 删除不必要的括号，减少语法分许的or和and树层，减少cpu消耗
- 常量传递。a=b and b=2转换为 a=2 and b=2。尽量不使用变量a=b或a=@va
- 消除没用的SQL条件
- where等号右边尽量不出现表达式计算；where中不要对字段进行表达式计算、函数的使用

#### 外连接优化
即将外连接转为内连接
- 优化处理器处理外连接比内连接步骤多且耗时
- 外连接消除后，优化器选择多表连接顺序有更多选择，可以择优而选
- 可以将筛选条件最为严格的表作为外表（连接顺序最前面，是多层循环体的外循环层）

可以减少不必要的I/O开销，能加快算法执行的速度
on a.id=b.id与where a.id=b.id的差别，on则表进行连接，where则进行数据对比

`注意`：前提必须是结果为NULL决绝（即条件限制不要NULL数据行，语意上是内连接）

#### exists和in的优化
转自：[浅析MySQL中exists与in的使用](https://www.cnblogs.com/beijingstruggle/p/5885137.html)
mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的

如果查询的两个表大小相当，那么用in和exists差别不大
**如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in**

not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快
