### 二叉树

二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒

#### 满二叉树

在一棵二叉树中，如果所有分支结点都有左孩子和右孩子结点，并且叶子结点都集中在二叉树的最下层，这样的树叫做满二叉树
![满二叉树](https://i.loli.net/2018/01/16/5a5e078d5f617.png)

#### 完全二叉树

若二叉树中最多只有最下面两层的结点的度数可以小于2，并且最下面一层的叶子结点都是依次排列在该层最左边的位置上，则称为完全二叉树
![完全二叉树](https://i.loli.net/2018/01/16/5a5e07d385ca4.png)

#### 二叉树遍历

**先序遍历**
1. 访问根结点
2. 先序遍历左子树
3. 先序遍历右子树

**中序遍历**
1. 中序遍历左子树
2. 访问根结点
3. 中序遍历右子树

**后续遍历**
类似

#### 什么是二叉排序树（bst）
二叉排序树（Binary Sort Tree）又称二叉查找树。 它或者是一棵空树；或者是具有下列性质的二叉树：
1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值
2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值
3. 左、右子树也分别为二叉排序树
![二叉排序树](https://i.loli.net/2018/01/16/5a5e09438c001.png)

**BST的基本操作**
从定义可以看去BST树没有重复元素

**1.1 BST的搜索**
- 先和这棵树的根比
- 如果比这个树根小就和这个树根的左子树的根比，否则就和这个树根的右子树比
- 重复2过程，直到根为空为止

**1.2 BST的增添元素算法实现**
- 先搜所以下所增添的key，在不在此树里面
- 如果没有找到，则申请空间，把key加入里面返回true，否则返回false

**1.3 BST删除元素的算法实现**

删除总共有3种情况，1只有左子树；2，只有右子树；3，左右子树都有

- 只有左子树 就把他双亲节点的左孩子指向删除节点的左子树
- 只有右子树 就把他双亲节点的左孩子指向删除节点的右子树
- 左右都有的 为了要保持树的顺序我们就要找比4大的且要离4最近的，那就是他的后继，当然你找前继也是可以的。此图是找他的后继。我们找到后就用4的后继替换4，最后删除后继这个节点

![左右都有](https://i.loli.net/2018/01/16/5a5e0bd604283.png)


#### 什么是AVL
平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树

根据它的发明者G. M. Adelson-Velskii和E. M. Landis命名的。它是一种特殊的二叉搜索树。

平衡因子(bf)：结点的左子树的深度减去右子树的深度，那么显然-1<=bf<=1。

平衡二叉树是在二叉排序树(BST)上引入的(这一点很重要哦，下图为例），就是为了解决二叉排序树的不平衡性导致时间复杂度大大下降，那么AVL就保持住了(BST)的最好时间复杂度O(logn)，所以每次的插入和删除都要确保二叉树的平衡，那么怎么保持平衡呢？如果还不理解看看下面的图吧
![](https://i.loli.net/2018/01/16/5a5e0c6fdd534.png)

#### 旋转操作

为了解决AVL在插入删除后仍能保持平衡而做的操作

各大教课书上讲的都是左旋与右旋，其实感觉叫逆旋顺旋更合适

![](https://i.loli.net/2018/01/16/5a5e198d9fd4c.png)

转 图片转自 http://blog.csdn.net/collonn/article/details/20128205

#### 红黑树

一种二叉查找树，但在每个节点上增加一个存储位表示节点的颜色，可以是Red或Black。 通过对任何一条从根到叶子的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的

一棵红黑树是指一棵满足下述性质的二叉搜索树（BST, binary search tree）：
1. 每个结点或者为黑色或者为红色
2. 根结点为黑色
3. 每个叶结点(实际上就是NULL指针)都是黑色的
4. 如果一个结点是红色的，那么它的两个子节点都是黑色的（也就是说，不能有两个相邻的红色结点）
5. 对于每个结点，从该结点到其所有子孙叶结点的路径中所包含的黑色结点数量必须相同

**定义详解**： 根据性质 5：红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的“黑色高度（black-height）”。 性质 4 则保证了**从根节点到叶子节点的最长路径的长度不会超过任何其他路径的两倍**。假如有一棵黑色高度为 3 的红黑树：从根节点到叶节点的最短路径长度是 2，该路径上全是黑色节点（黑节点 – 黑节点 – 黑节点）。最长路径也只可能为 4，在每个黑色节点之间插入一个红色节点（黑节点 – 红节点 – 黑节点 – 红节点 – 黑节点），性质 4 保证绝不可能插入更多的红色节点。由此可见，**红黑树中最长路径就是一条红黑交替的路径**。

对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。 提示：排序二叉树的深度直接影响了检索的性能，正如前面指出，当插入节点本身就是由小到大排列时，排序二叉树将变成一个链表，这种排序二叉树的检索性能最低：N 个节点的二叉树深度就是 N-1。 红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。 由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。 但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树。

**红黑树的插入操作：**

在对红黑树进行插入操作时，我们一般总是插入红色的节点，因为这样可以在插入过程中尽量避免对树的调整。 那么，我们插入一个节点后，可能会使原树的哪些性质改变列? 由于，我们是按照二叉树的方式进行插入，因此元素的搜索性质不会改变
如果插入的节点是根节点，性质2会被破坏，如果插入节点的父节点是红色，则会破坏性质4。 因此，总而言之，插入一个红色节点只会破坏性质2或性质4。 我们的恢复策略很简单

**情况1：插入的是根节点**
- 原树是空树，此情况只会违反性质2。
- 对策：直接把此节点涂为黑色。

**情况2：插入的节点的父节点是黑色**
- 此不会违反性质2和性质4，红黑树没有被破坏
- 对策：什么也不做

**情况3：当前节点的父节点是红色且祖父节点的另一个子节点（叔叔节点）是红色**
- 此时父节点的父节点一定存在，否则插入前就已不是红黑树。与此同时，又分为父节点是祖父节点的左子还是右子，对于对称性，我们只要解开一个方向就可以了。 在此，我们只考虑父节点为祖父左子的情况。 同时，还可以分为当前节点是其父节点的左子还是右子，但是处理方式是一样的。我们将此归为同一类
- 将当前节点的父节点和叔叔节点涂黑，祖父节点涂红，把当前节点指向祖父节点，从新的当前节点重新开始算法

**情况4：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右子**
- 对策 当前节点的父节点做为新的当前节点，以新当前节点为支点左旋

**情况5：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左子**
- 父节点变为黑色，祖父节点变为红色，在祖父节点为支点右旋


#### 红黑树与AVL树比较

1. 如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。
2. 其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高
3. map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的

**谣言1：RBTREE的平均统计性能比 AVL 好**
统计下来一千万个节点插入 AVL 共旋转 7053316 次（先左后右算两次），RBTREE共旋转 5887217 次，RBTREE看起来少是吧？应该很快？但是别忘了 RBTREE 再平衡的操作除了旋转外还有再着色，每次再平衡噼里啪啦的改一片颜色，父亲节点，叔叔，祖父，兄弟节点都要访问一圈，这些都是代价，再者平均树高比 AVL 高也成为各项操作的成本

**谣言2：RBTREE 一般情况只比 AVL 高一两层，这个代价忽略不**计纯粹谣言，随便随机一下，一百万个节点的 RBTREE 树高27，和一千万个节点的 AVL树相同，而一千万个节点的 RBTREE 树高 33，比 AVL 多了 6 层，这还不是最坏情况，最坏情况 AVL 只有 1.440 * log(n + 2) - 0.328, 而 RBTREE 是 2 * log(n + 1)，也就是说同样100万个节点，AVL最坏情况是 28 层，rbtree 最坏可以到 39 层

**谣言3：AVL树删除节点是需要回溯到根节点**
我以前也是这么写 AVL 树的，后来发现根据 AVL 的定义，可以做出两个推论，再平衡向上回溯时：
插入更新时：如当前节点的高度没有改变，则上面所有父节点的高度和平衡也不会改变。删除更新时：如当前节点的高度没有改变且平衡值在 [-1, 1] 区间，则所有父节点的高度和平衡都不会改变。
根据这两个推论，AVL的插入和删除大部分时候只需要向上回溯一两个节点即可，范围十分紧凑

**谣言4：虽然二者插入一万个节点总时间类似，但是rbtree树更平均，avl有时很快，有时慢很多，rbtree 只需要旋转两次重新染色就行了，比 avl 平均**

完全说反了，avl是公认的比rbtree平均的数据结构，插入时间更为平均，rbtree才是不均衡，有时候直接插入就返回了（上面是黑色节点），有时候插入要染色几个节点但不旋转，有时候还要两次旋转再染色然后递归到父节点。该说法最大的问题是以为 rbtree 插入节点最坏情况是两次旋转加染色，可是忘记了一条，需要向父节点递归，比如：当前节点需要旋转两次重染色，然后递归到父节点再旋转两次重染色，再递归到父节点的父节点，直到满足 rbtree 的5个条件。这种说法直接把递归给搞忘记了，翻翻看 linux 的 rbtree 代码看看，再平衡时那一堆的 while 循环是在干嘛？不就是向父节点递归么？avl和rbtree 插入和删除的最坏情况都需要递归到根节点，都可能需要一路旋转上去，否则你设想下，假设你一直再树的最左边插入1000个新节点，每次都想再局部转两次染染色，而不去调整整棵树，不动根节点，可能么？只是说整个过程avl更加平均而已

**结论**：AVL / RBTREE 真的差不多，AVL被早期各种乱七八糟的实现和数学上的“统计”给害了，别盯着 linux 用了 rbtree 就觉得 rbtree 一定好过 avl了，solaris 里面大范围的使用 avltree ，完全没有 rbtree 的痕迹那。

**上面摘抄自 知乎问答作者：韦易笑**

#### B树'

计算机有一个局部性原理，就是说，当一个数据被用到时，其附近的数据也通常会马上被使用。
所以当你用红黑树的时候，你一次只能得到一个键值的信息，而用B树，可以得到最多M-1个键值的信息。这样来说B树当然更好了。
另外一方面，同样的数据，红黑树的阶数更大，B树更短，这样查找的时候当然B树更具有优势了，效率也就越高'

**概念**
B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构

**规则**
- 树种的每个节点最多拥有m个子节点且m>=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）
- 除根节点外每个节点的关键字数量**大于等于ceil(m/2)-1个，小于等于m-1个**，非根节点关键字数必须>=2;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)
- 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子
- 如果一个非叶节点有N个子节点，则该节点的关键字数等于N-1;
- 所有节点关键字是按递增次序排列，并遵循左小右大原则;

![B树](https://i.loli.net/2018/01/17/5a5ee4e0ad151.png)

**特点**
B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度

#### 2-3查找树
- B即 `Balanced` 平衡的意思
- 2-3树是Ｂ树的特例
- 结点最大的孩子数目成为Ｂ树的阶（order）,2-3树的阶是３阶Ｂ树

**定义**
- 要么为空，要么由以下节点组成
- 2-结点，含有一个键(及其对应的值)和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点
- 对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。


#### B+树
B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别

- B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每个节点所能保存的关键字大大增加
- B+树的根节点关键字数量和其子节点个数相等
- B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样

![B+树](https://i.loli.net/2018/01/17/5a5ee84baf187.png)

#### B*树

B*树是B+树的变种，在B+树的非根和非叶子结点再增加指向兄弟的指针,相对于B+树他们的不同之处如下：
- 首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为（cei(2/3*m)）
- B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来

**特点**
在B+树的基础上因其初始化的容量变大，使得节点空间使用率更高，而又存有兄弟节点的指针，可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少

![B*树](https://i.loli.net/2018/01/17/5a5ee91a0a64c.png)

#### 为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引

- B+tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了
- 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当

B/B+ 树就是N叉（N-ary）平衡树了，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用

**B树**：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；
**B+树**：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；
**B*树**：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率

从1/2提高到2/3；

以上几种树都是有序的，如果你采用合适的算法遍历整个数，可以得到一个有序的列表。这也是为什么如果有数据库索引的情况下，你order by你索引的值，就会速度特别快，因为它并没有给你真的排序，只是遍历树而已

#### Trie树

Trie树，又叫字典树、前缀树（Prefix Tree）、单词查找树 或 键树，是一种多叉树结构
![Trie](https://i.loli.net/2018/01/17/5a5efed7b44e7.png)
上图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”}
从上图可以归纳出Trie树的基本性质:
1. 根节点不包含字符，除根节点外的每一个子节点都包含一个字符
2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串
3. 每个节点的所有子节点包含的字符互不相同

通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。

可以看出，Trie树的关键字一般都是字符串，而且Trie树把每个关键字保存在一条路径上，而不是一个结点中。另外，两个有公共前缀的关键字，在Trie树中前缀部分的路径相同，所以Trie树又叫做前缀树（Prefix Tree）

**Trie树的优缺点**

**优点**

1. 插入和查询的效率很高，都为O(m)，其中 m 是待插入/查询的字符串的长度
2. Trie树中不同的关键字不会产生冲突
3. Trie树只有在允许一个关键字关联多个值的情况下才有类似hash碰撞发生
4. Trie树不用求 hash 值，对短字符串有更快的速度。通常，求hash值也是需要遍历字符串的
5. Trie树可以对关键字按字典序排序

**缺点**
1. 当 hash 函数很好时，Trie树的查找效率会低于哈希搜索
2. 空间消耗比较大
