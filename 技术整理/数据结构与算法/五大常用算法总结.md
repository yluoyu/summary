递归与迭代的区别
参考：[深究递归和迭代的区别、联系、优缺点及实例对比](http://blog.csdn.net/laoyang360/article/details/7855860)
参考：[迭代是人，递归是神（迭代与递归的总结：比较）](http://blog.csdn.net/lg1259156776/article/details/46849809)

从直观上讲，递归是将大问题化为相同结构的小问题，从待求解的问题出发，一直分解到已经已知答案的最小问题为止，然后再逐级返回，从而得到大问题的解（一个非常形象的例子就是分类回归树 classification and regression tree，从root出发，先将root分解为另一个(root,sub-tree)，就这样一直分解，直到遇到leafs后逐层返回）；而迭代则是从已知值出发，通过递推式，不断更新变量新值，一直到能够解决要求的问题为止

在数学上，递归强调的是，新的值与前面计算的好几个值有关系；比如斐波那契数列
`F6=F5+F4`
而迭代一般是只是X{n+1} 与X{n} 之间进行计算，即X{n+1} =F(X{n}) ;
计算机进行算法分析中，（我对递归的复杂度分析不熟，可以去看看《算法导论》）递归方法一般是将递归式转换成树形结构，然后是不断向下计算吧

以斐波那契数列的求解为例，通过两种典型的实现进行对比：
- fib(0)=0;
- fib(1)=1;
- fib(n)=fib(n-1)+fib(n-2);

递归的实现
```java
int fib(int n){
     if(n>1)
        return fib(n-1) + fib(n-2);
     else
        return n; // n = 0, 1时给出recursion终止条件
}
```
迭代的实现
```java
int fib(int n){
    int i, temp0, temp1, temp2;
    if(n<=1) return n;
    temp1 = 0;
    temp2 = 1;
    for(i = 2; i <= n; i++){
        temp0 = temp1 + temp2;
        temp2 = temp1;
        temp1 = temp0;
    }
    return temp0;
}
```
递归算法从思想上更加贴近人们处理问题的思路，而且所处的思想层级算是高层（神），而迭代则更加偏向于底层（人），所以从执行效率上来讲，底层(迭代)往往比高层(递归)来的高，但高层(递归)却能提供更加抽象的服务，更加的简洁

据说有人归纳了计算机的五大常用算法，它们是贪婪算法，动态规划算法，分治算法，回溯算法以及分支限界算法。虽然不知道为何要将这五个算法归为最常用的算法，但是毫无疑问，这五个算法是有很多应用场景的，最优化问题大多可以利用这些算法解决。算法的本质就是解决问题。当数据量比较小时，其实根本就不需要什么算法，写一些for循环完全就可以很快速的搞定了，但是当数据量比较大，场景比较复杂的时候，编写for循环就是一个很不明智的方式了。一是耗时，二是写出的代码绝对是天书。当然还有第三点，这点也是最重要的，写代码是一种艺术，而不是搬砖。前面的文章里对这五种算法都已经做了详细的讲解和归纳，本文主要是一个总结，将这五种算法整理到一起来对比，分析一下。

- 每个阶段只有一个状态->递推；
- 每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
- 每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
- 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。
> 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到
这个性质叫做最优子结构
> 而不管之前这个状态是如何得到的

这个性质叫做无后效性



贪婪算法

动态规划算法

分治算法

回溯算法
