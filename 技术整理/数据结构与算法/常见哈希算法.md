散列表,它是基于高速存取的角度设计的，也是一种典型的“空间换时间”的做法。顾名思义，该数据结构能够理解为一个线性表，可是当中的元素不是紧密排列的，而是可能存在空隙

解决冲突是一个复杂问题。冲突主要取决于：
1）散列函数，一个好的散列函数的值应尽可能平均分布
2）处理冲突方法
3）负载因子的大小 太大不一定就好，并且浪费空间严重，负载因子和散列函数是联动的

解决冲突的办法：
- 线性探查法：冲突后，线性向前试探，找到近期的一个空位置。缺点是会出现堆积现象。存取时，可能不是同义词的词也位于探查序列，影响效率。
- 双散列函数法：在位置d冲突后，再次使用还有一个散列函数产生一个与散列表桶容量m互质的数c，依次试探(d+n*c)%m，使探查序列跳跃式分布


经常使用的构造散列函数的方法:
1. `直接寻址法`。取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a•key + b，当中a和b为常数（这样的散列函数叫做自身函数
2. `数字分析法` 分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址
3. `平方取中法` 取keyword平方后的中间几位作为散列地址
4. `折叠法` 将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址
5. 随机数法 选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合
6. 除留余数法 取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p<=m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，若p选的不好，easy产生同义词


了解了hash基本定义，就不能不提到一些著名的hash算法，MD5 和 SHA-1 能够说是眼下应用最广泛的Hash算法，而它们都是以 MD4 为基础设计的
1) MD4
MD4(RFC 1320)是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。它适用在32位字长的处理器上用快速软件实现–它是基于 32 位操作数的位操作来实现的
2) MD5
它对输入仍以512位分组，其输出是4个32位字的级联，与 MD4 同样。MD5比MD4来得复杂，而且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好
3) SHA-1 及其它
SHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1 设计时基于和MD4同样原理,而且模仿了该算法

哈希表不可避免冲突(collision)现象：对不同的keyword可能得到同一哈希地址 即key1≠key2，而hash(key1)=hash(key2)。因此，在建造哈希表时不仅要设定一个好的哈希函数，并且要设定一种处理冲突的方法。可例如以下描写叙述哈希表：依据设定的哈希函数H(key)和所选中的处理冲突的方法，将一组keyword映象到一个有限的、地址连续的地址集(区间)上并以keyword在地址集中的“象”作为对应记录在表中的存储位置，这样的表被称为哈希表

应用于加密的Hash函数已经探讨过太多了，在作者的博客里面有更具体的介绍。所以，本文仅仅探讨用于查找的Hash函数。
Hash函数应用的主要对象是数组（比方，字符串），而其目标通常是一个int类型。下面我们都依照这样的方式来说明。
一般的说，Hash函数能够简单的划分为例如以下几类：
1. 加法Hash；
2. 位运算Hash；
3. 乘法Hash；
4. 除法Hash；
5. 查表Hash；
6. 混合Hash；

#### 一 加法Hash
所谓的加法Hash就是把输入元素一个一个的加起来构成最后的结果。标准的加法Hash的构造例如以下
```
static int additiveHash(String key, int prime)
{
 int hash, i;
 for (hash = key.length(), i = 0; i < key.length(); i++)
  hash += key.charAt(i);
 return (hash % prime);
}
```
这里的prime是随意的质数，看得出，结果的值域为`[0,prime-1]`

#### 二 位运算Hash
这类型Hash函数通过利用各种位运算（常见的是移位和异或）来充分的混合输入元素。比方，标准的旋转Hash的构造例如以下
```
static int rotatingHash(String key, int prime)
{
 int hash, i;
 for (hash=key.length(), i=0; i
   hash = (hash<>28)^key.charAt(i);
 return (hash % prime);
}
```
