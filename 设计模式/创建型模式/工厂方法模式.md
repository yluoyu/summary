#### 定义
工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象

即：定义一个 用于创建对象 的接口。（但是让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类(即不同的facotory子类)中进行。）

![](https://i.loli.net/2018/03/09/5aa2a19fc5776.png)
跟简单工厂的区别：
> 工厂方法模式实现时，客户端需要决定实例化哪个工厂来生成产品，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来该改工厂类的，现在是修改客户端。

#### 主要作用

将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类

#### 解决的问题
工厂一旦需要生产新产品就需要修改工厂类的方法逻辑，违背了“开放 - 关闭原则”
>之所以可以解决简单工厂的问题，是因为工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中，此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类，符合开放封闭原则，克服了简单工厂模式中缺点

#### 设计原则
- 开闭原则

#### 模式组成
角色  | 关系  |  作用
--|---|--
抽象产品  | 具体产品的父类  |描述具体产品的公共接口
具体产品  |抽象产品的子类；工厂类创建的目标类   |描述生产的具体产品
抽象工厂  | 具体工厂的父类  |  描述具体工厂的公共接口
具体工厂  | 抽象工厂的子类；被外界调用  |描述具体工厂；实现FactoryMethod工厂方法创建产品的实例

#### 实例

- 背景：小成有一间塑料加工厂（仅生产A类产品）；随着客户需求的变化，客户需要生产B类产品
- 冲突：改变原有塑料加工厂的配置和变化非常困难，假设下一次客户需要再发生变化，再次改变将增大非常大的成本
- 解决方案：小成决定置办塑料分厂B来生产B类产品；

>即工厂方法模式

#### 使用步骤

**步骤1**. 创建抽象工厂类，定义具体工厂的公共接口
```java
abstract class Factory{
    public abstract Product Manufacture();
}
```
**步骤2**. 创建抽象产品类 ，定义具体产品的公共接口

```java
abstract class Product{
    public abstract void Show();
}
```
**步骤3**. 创建具体产品类（继承抽象产品类）， 定义生产的具体产品

```java
//具体产品A类
class  ProductA extends  Product{
    @Override
    public void Show() {
        System.out.println("生产出了产品A");
    }
}

//具体产品B类
class  ProductB extends  Product{

    @Override
    public void Show() {
        System.out.println("生产出了产品B");
    }
}
```
**步骤4**. 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法

```java
//工厂A类 - 生产A类产品
class  FactoryA extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductA();
    }
}

//工厂B类 - 生产B类产品
class  FactoryB extends Factory{
    @Override
    public Product Manufacture() {
        return new ProductB();
    }
}
```
**步骤5**. 外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例
```java
//生产工作流程
public class FactoryPattern {
    public static void main(String[] args){
        //客户要产品A
        Factory mFactoryA = new FactoryA(); // 要更换产品 只需要修改这个地方就可以
        mFactoryA.Manufacture().Show();

        //客户要产品B
        Factory mFactoryB = new FactoryB();
        mFactoryB.Manufacture().Show();
    }
}
```

#### 优点
- 更符合开-闭原则
   新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可.
   >简单工厂模式需要修改工厂类的判断逻辑
- 符合单一职责原则
  每个具体工厂类只负责创建对应的产品
  >简单工厂中的工厂类存在复杂的switch逻辑判断
- 不使用静态工厂方法，可以形成基于继承的等级结构
  >简单工厂模式的工厂类使用静态工厂方法

#### 缺点
- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销
- ~~由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度~~ `这个应该说的的简单工厂模式`
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类
- 一个具体工厂只能创建一种具体产品

#### 应用场景
- 当一个类不知道它所需要的对象的类时
  在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；
- 当一个类希望通过其子类来指定创建对象时
  在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中
