### 项目介绍

大部分情况，这是一场面试的开门题，面试官问这个问题，主要是考察你的概述能力和全局视野。有的人经常抱怨自己每天在堆业务，但没有成长。事实上，很多情况下确实在堆业务，但并不是没有成长的。并非做中间件或者技术架构才是成长，例如我们的需求分析能力，沟通协作能力，产品思维能力，抽象建模能力等都是一个非常重要的硬实力
好的，现在进入正文。
- 明确项目是做什么的
- 明确项目的价值。（为什么做这个项目，它解决了用户什么痛点，它带来什么价值？）
- 明确项目的功能。（这个项目涉及哪些功能？）
- 明确项目的技术。（这个项目用到哪些技术？）
- 明确个人在项目中的位置和作用。（你在这个项目的承担角色？）
- 明确项目的整体架构
- 明确项目的优缺点,如果重新设计你会如何设计
- 明确项目的亮点。（这个项目有什么亮点？）
- 明确技术成长。（你通过这个项目有哪些技术成长？）

### Java基础
- List 和 Set 的区别
- HashSet 是如何保证不重复的
  - 内部使用HashMap保存元素，元素值作为map的key,map的value是固定值
  - HashMap保证key不重复是用到对象的`hashCode`和`equals`方法进行的判断
- HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?
  - [并发下HashMap为什么不是线程安全的](https://blog.csdn.net/chisunhuang/article/details/79041656)
  - 总结下就是 扩容的时候有可能形成`循环链表`
- HashMap 的扩容过程
- HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？
  - [HashMap在Java1.7与1.8中的区别](https://www.cnblogs.com/stevenczp/p/7028071.html)
  - 使用一个Node数组来存储数据，但这个Node可能是链表结构，也可能是红黑树结构,链表长度超过8个则使用红黑树，需要注意的是真正想要利用JDK1.8的好处key的对象，必须正确的实现了`Compare接口`
- final finally finalize
- 强引用 、软引用、 弱引用、虚引用
  - [Java四种引用包括强引用，软引用，弱引用，虚引用](https://www.cnblogs.com/yw-ah/p/5830458.html)
  - 强引用 只要引用存在，垃圾回收器永远不会回收
  - 软引用 内存溢出之前进行回收 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值
  - 弱引用 第二次垃圾回收时回收 主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记
  - 虚引用 虚引用是每次垃圾回收的时候都会被回收，通过虚引用的get方法永远获取到的数据为null，因此也被成为幽灵引用 虚引用主要用于`检测对象是否已经从内存中删除`
- Java反射
  - JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制
  - [Java基础之—反射](https://blog.csdn.net/sinat_38259539/article/details/71799078)
- Arrays.sort 实现原理和 Collection 实现原理
  - 不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来
  - 归并排序MergeSort对已经反向排好序的输入时复杂度为O(n^2)，而timsort就是针对这种情况，对MergeSort进行优化而产生的，平均复杂度为n*O(log n),最好的情况为O(n)，最坏情况n*O(log n)。并且TimSort是一种稳定性排序。思想是先对待排序列进行分区，然后再对分区进行合并，看起来和MergeSort步骤一样，但是其中有一些针对反向和大规模数据的优化处理
- LinkedHashMap的应用
- cloneable接口实现原理
  - 从JVM的角度看，这就是一个标记接口而已。实现了就是打上cloneable标记，没实现就是没这个标记。然后到clone()的基本实现中，JVM会去检测要clone的对象的类有没有被打上这个标记，有就让clone，没有就抛异常
  -
- 异常分类以及处理机制
  - 检查和非检查是对于javac来说的，这样就很好理解和区分
  - 非检查异常（unckecked exception）：Error 和 RuntimeException 以及他们的子类
  - 检查异常（checked exception）：除了Error 和 RuntimeException的其它异常
  - `finally`块不管异常是否发生，只要对应的try执行了，则它一定也执行。只有一种方法让finally块不执行：System.exit()
- wait和sleep的区别
  - “sleep是Thread类的方法,wait是Object类中定义的方法”。尽管这两个方法都会影响线程的执行行为，但是本质上是有区别的
  - Thread.sleep不会导致锁行为的改变，如果当前线程是拥有锁的，那么Thread.sleep不会让线程释放锁。如果能够帮助你记忆的话，可以简单认为和锁相关的方法都定义在Object类中，因此调用Thread.sleep是不会影响锁的相关行为
  - Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间
- 数组在内存中如何分配
  - Java里的数组类型是由JVM直接实现的，没有对应的Java源码文件

#### Java 并发
- synchronized 的实现原理以及锁优化？
  - [synchronized实现原理以及其中锁优化的归纳总结](https://blog.csdn.net/thousa_ho/article/details/77992743)
  - `自旋锁Spin Lock` 对于执行时间很短的代码块有性能提高
  - `偏向锁Biased Lock` 在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了
  - `轻量级锁` 在无竞争的情况下使用CAS操作去消除同步使用的互斥量
  - 锁粗化(Lock Coarsening)
  - 锁消除(Lock Elimination)
  - 适应性自旋(Adaptive Spinning)
- volatile 的实现原理？
  - 保证可见性、不保证原子性
  - 禁止指令重排序
  - 为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障”的东西来完成。内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制
  - 对volatile变量的写操作与普通变量的主要区别：
    - 修改volatile变量时会强制将修改后的值刷新的主内存中
    - 修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值
- Java 的信号灯？
  - `Semaphore` 可以维护当前访问自身的线程个数，并提供了同步机制。使用Semaphore可以控制同时访问资源的线程个数（即允许n个任务同时访问这个资源）
- synchronized 在静态方法和普通方法的区别？
  - 锁的对象上的区别 一个是当前对象一个是类对象
- 怎么实现所有线程在等待某个事件的发生才会去执行？
  - [Java并发：等待事件发生后所有线程继续执行](https://blog.csdn.net/jiyiqinlovexx/article/details/51236323)
  - 倒数锁 CountDownLatch
  - 阻塞队列BlockingQueue
  - 信号量Semaphore
  - 栅栏CyclicBarrier
- CAS？CAS 有什么缺陷，如何解决？
  - `Compare And Set` 是一种常见的降低读写锁冲突，保证数据一致性的乐观锁机制
  - ABA问题，添加版本号
  -
- synchronized 和 lock 有什么区别？
  - `锁的释放` lock 需要手动释放，注意lock的一般使用形式 `try catch finally` 注意在finally里释放
  - `获取锁的方式` lock 可以trylock 也可以设置等待时间
  - `公平` lock可以实现公平(默认非公平)
- Hashtable 是怎么加锁的 ？
  - 内部的方法基本都是synchronized
  - HashTable不允许有null值的存在
- HashMap 的并发问题？
- ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？
- AQS
  - `AbstractQueuedSynchronizer` 抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch
  - [Java并发之AQS详解](https://www.cnblogs.com/daydaynobug/p/6752837.html)
- 如何检测死锁？怎么预防死锁？
  - jstack
  - 避免死锁的技术
    - 加锁顺序 线程按照一定的顺序加锁
    - 加锁时限 线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁
    - 死锁检测
- Java 内存模型？
  - 主内存与工作内存
  - 注意与内存区域的区别 区域包括：方法区 堆 虚拟机栈 本地方法栈 程序计数器
- 如何保证多线程下 i++ 结果正确？
  - 根本原因是i++不是原子操作
  - 加锁同步，使用synchronized或者ReentrantLock都可以解决这个问题
  - volatile不行，因为只能保证可见性，不能保证原子性
  - 建议使用AtomicInteger，提供了原子性的自增操作
- 线程池的种类，区别和使用场景？
  - [java线程池种类和使用场景](https://blog.csdn.net/NeilGY/article/details/78595258)
  - shutdown和shutdownNow的区别
  - 线程池按以下行为执行任务
    - 1.当线程数小于核心线程数时，创建线程
    - 2.当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列
    - 3.当线程数大于等于核心线程数，且任务队列已满
      - 1.若线程数小于最大线程数，创建线程
      - 2.若线程数等于最大线程数，抛出异常，拒绝任务
  - 可选择的阻塞队列BlockingQueue
    - 无界队列 常用的为无界的LinkedBlockingQueue(默认容量Integer.MAX_VALUE)，使用该队列做为阻塞队列时要尤其当心，当任务耗时较长时可能会导致大量新任务在队列中堆积最终导致OOM
    - 有界队列 一类是遵循FIFO原则的队列如ArrayBlockingQueue与有界的LinkedBlockingQueue，另一类是优先级队列如PriorityBlockingQueue。PriorityBlockingQueue中的优先级由任务的Comparator决定
    - 同步移交 如果不希望任务在队列中等待而是希望将任务直接移交给工作线程，可使用SynchronousQueue作为等待队列。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制
  - 可选择的饱和策略RejectedExecutionHandler
    - AbortPolicy中止策略 `默认饱和策略` 该策略时在饱和时会抛出RejectedExecutionException（继承自RuntimeException），调用者可捕获该异常自行处理
    - DiscardPolicy抛弃策略 不做任何处理直接抛弃任务
    - DiscardOldestPolicy抛弃旧任务策略 先将阻塞队列中的头元素出队抛弃，再尝试提交任务。如果此时阻塞队列使用PriorityBlockingQueue优先级队列，将会导致优先级最高的任务被抛弃，因此不建议将该种策略配合优先级队列使用
    - CallerRunsPolicy调用者运行 既不抛弃任务也不抛出异常，直接运行任务的run方法，换言之将任务回退给调用者来直接运行。使用该策略时线程池饱和后将由调用线程池的主线程自己来执行任务，因此在执行任务的这段时间里主线程无法再提交新任务，从而使线程池中工作线程有时间将正在处理的任务处理完成
  - 四种常用线程池解析
    - CachedThreadPool
      - 它是一个可以无限扩大的线程池
      - 它比较适合处理执行时间比较小的任务
    - FixedThreadPool
      - 一种固定大小的线程池
      - corePoolSize和maximunPoolSize都为用户设定的线程数量nThreads
      - 由于阻塞队列是一个无界队列，因此永远不可能拒绝任务(疑问:当达到Integer.MAX_VALUE是否会拒绝任务)
    - SingleThreadExecutor
      - 它只会创建一条工作线程处理任务
      - 采用的阻塞队列为LinkedBlockingQueue
      - 使用装饰模式增强了ScheduledExecutorService（1）的功能，不仅确保只有一个线程顺序执行任务，也保证线程意外终止后会重新创建一个线程继续执行任务
    - ScheduledThreadPool
      - 用来处理延时任务或定时任务
      - 它接收SchduledFutureTask类型的任务，有两种提交任务的方式
        - scheduledAtFixedRate
        - scheduledWithFixedDelay
      - 它采用DelayQueue存储等待的任务
        - DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若time相同则根据sequenceNumber排序
        - DelayQueue也是一个无界队列
- 分析线程池的实现原理和线程的调度过程？
  - 主要是线程的复用
  - ThreadPoolExecutor主要Worker类来控制线程的复用
- 线程池如何调优，最大数目如何确认？
  - 线程池中的最大线程数量应该被限制，才不会导致系统资源耗尽
  - 相反的，如果线程执行的是CPU密集型任务而不是IO密集型任务，服务器的物理内核数就应该被视为是有限的资源，这样创建的线程数就不应该超过系统的内核数
  - 利特尔法则
  - 拆分线程池 在微服务或者面向服务架构（SOA）中，通常需要访问多个后端服务。如果其中一个服务性能下降，可能会引起线程池线程耗尽，从而影响对其他服务的请求
- ThreadLocal原理，用的时候需要注意什么？
  - [java ThreadLocal(应用场景及使用方式及原理)](https://www.cnblogs.com/yxysuanfa/p/7125761.html)
  - [深入分析 ThreadLocal 内存泄漏问题](http://www.importnew.com/22039.html)
  - ThreadLocal<T>变量一般要声名成static类型，根据实际情况，ThreadLocal变量声名时也多加上private final关键词表明它时类内私有、引用不可修改
  - ThreadLocalMap存储数据，底层其实是个数组`Entry[] table`
  - 每次使用完ThreadLocal，都调用它的remove()方法，清除数据
- CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?
  - CountDownLatch 倒数锁，使用一次后失效，不可重置
  - CyclicBarrier栅栏 可以循环使用
- LockSupport工具
  - [Java并发工具类LockSupport](https://blog.csdn.net/congduan/article/details/48710129)
  - 可以精准地阻塞和唤醒特定的线程，并作为其他同步类的原语，LockSupport包含一个`park(Object blocker)`和`unpark(Object blocker)`方法，分别用于阻塞和唤醒
- Condition接口及其实现原理
  - [Java多线程Condition接口原理详解](https://blog.csdn.net/fuyuwei2015/article/details/72602182)
  - Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的
  - 一般都会将Condition对象作为成员变量。当调用`await()`方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的`signal()`方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁
- Fork/Join框架的理解
  - [Fork/Join框架详解](https://www.cnblogs.com/senlinyang/p/7885964.html)
  - Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork/Join框架要完成两件事情
    - `任务分割`：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割
    - `执行任务并合并结果`：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据
    -
- 分段锁的原理,锁力度减小的思考
  - 基于粒度更小的分段锁
  - 容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术
- 阻塞队列以及各个阻塞队列的特性
  - 延时队列 DelayQueue
  - 同步队列 SynchronousQueue
  - 链表阻塞队列 LinkedBlockingQueue
  - 数组阻塞队列 ArrayBlockingQueue
  - 优先级阻塞队列 PriorityBlockingQueue

### Spring
- BeanFactory 和 FactoryBean？
  - [Spring FactoryBean应用](https://www.jianshu.com/p/6f0a59623090)
  - BeanFactory，以Factory结尾，表示它是一个工厂类(接口)，用于管理Bean的一个工厂
  - 以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean<T>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&符号来获取
  - 一般情况下，Spring通过反射机制利用bean的class属性指定实现类来实例化bean 。在某些情况下，实例化bean过程比较复杂，如果按照传统的方式，则需要在<bean>中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.Springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化bean的逻辑
- Spring IOC 的理解，其初始化过程？
  - [SPRING原理解析-Ioc容器初始化](https://blog.csdn.net/john2522/article/details/39308835)
  - IoC文英全称Inversion of Control，即`控制反转`，“把某些业务对象的的控制权交给一个平台或者框架来同一管理，这个同一管理的平台可以称为IoC容器。”
  - IoC容器的初始化就是含有BeanDefinition信息的Resource的定位、载入、解析、注册四个过程，最终我们配置的bean，以beanDefinition的数据结构存在于IoC容器即内存中
- BeanFactory 和 ApplicationContext？
  - ApplicationContext接口,它由BeanFactory接口派生而来，因而提供BeanFactory所有的功能
  - ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承
  - ApplicationContext包还提供了以下的功能
    - MessageSource, 提供国际化的消息访问
    - 资源访问，如URL和文件 ResourceLoader
    - 事件传播 ApplicationEvent ApplicationListener
    - 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层
- Spring Bean 的生命周期，如何被管理的？
  - [Spring中Bean的生命周期是怎样的](https://www.zhihu.com/question/38597960)
  - 1.实例化Bean
  - 2.设置对象属性（依赖注入）
  - 3.注入Aware接口
  - 4.BeanPostProcessor
    - postProcessBeforeInitialzation
    - postProcessAfterInitialzation
  - InitializingBean与init-method
    - init-method本质上仍然使用了InitializingBean接口
  - DisposableBean和destroy-method
- Spring Bean 的加载过程是怎样的？
  - [Spring解密 - Bean的加载流程](https://segmentfault.com/a/1190000012887776#articleHeader6)
  - getBean(String name) 加载指的是这部分
    - 转换 BeanName
    - 加载单例
    - 创建 Bean
    - 初始化 Bean
    - 增强的 Bean
    - 循环依赖
- 如果要你实现Spring AOP，请问怎么实现？
  - [Spring实现AOP的多种方式](https://www.cnblogs.com/best/p/5736422.html)
  - 所谓的动态代理就是说AOP框架不会去修改字节码，而是在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。
  - Spring AOP中的动态代理主要有两种方式
    - `JDK动态代理` 通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是`InvocationHandler`接口和`Proxy`类
    - `CGLIB动态代理` CGLIB是通过`继承的方式`做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的
- 如果要你实现Spring IOC，你会注意哪些问题？
  - [谈谈对Spring IOC的理解](https://www.cnblogs.com/xdp-gacl/p/4249939.html)
- Spring 是如何管理事务的，事务管理机制？
  - [简单说说spring的事务机制，以及是如何管理的](https://blog.csdn.net/jie_liang/article/details/77600742)
  - Spring的事务机制包括声明式事务和编程式事务
    - 编程式事务管理 Spring推荐使用TransactionTemplate
    - 声明式事务管理 将我们从复杂的事务处理中解脱出来，获取连接，关闭连接、事务提交、回滚、异常处理等这些操作都不用我们处理了，Spring都会帮我们处理.声明式事务管理使用了AOP面向切面编程实现的，本质就是在目标方法执行前后进行拦截。在目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或是回滚事务
  - 如何管理的.Spring事务管理主要包括3个接口，Spring的事务主要是由他们三个共同完成的
    - PlatformTransactionManager 事务管理器--主要用于平台相关事务的管理 主要有三个方法：
      - commit  事务提交
      - rollback  事务回滚
      - getTransaction  获取事务状态
    - TransactionDefinition 事务定义信息--用来定义事务相关的属性，给事务管理器PlatformTransactionManager使用,主要四个方法：
      - getIsolationLevel：获取隔离级别
      - getPropagationBehavior：获取传播行为
      - getTimeout：获取超时时间
      - isReadOnly：是否只读
    - TransactionStatus 事务具体运行状态--事务管理过程中，每个时间点事务的状态信息
- Spring 的不同事务传播行为有哪些，干什么用的？
  - PROPAGATION_REQUIRED 支持当前事务，假设当前没有事务。就新建一个事务 这是最常见的选择
  - PROPAGATION_SUPPORTS 支持当前事务，假设当前没有事务，就以非事务方式运行
  - PROPAGATION_MANDATORY 支持当前事务，假设当前没有事务，就抛出异常
  - PROPAGATION_REQUIRES_NEW 新建事务，假设当前存在事务。把当前事务挂起
  - PROPAGATION_NOT_SUPPORTED
  - PROPAGATION_NEVER
  - PROPAGATION_NESTED
- Spring 中用到了那些设计模式？
  - `工厂模式` 各种BeanFactory以及ApplicationContext创建中都用到
  - 单例模式 创建bean的时候
  - 代理模式 在Aop实现中用到了JDK的动态代理
  - 适配器（Adapter）
  - 模板方法模式：解决代码重复问题
  - 观察者（Observer） Observer模式常用的地方是listener的实现。如ApplicationListener
- Spring MVC 的工作原理？
  - [SpringMVC的工作原理图](https://www.cnblogs.com/xiaoxi/p/6164383.html)
- Spring 循环注入的原理？
  - [DI之循环依赖](http://www.importnew.com/17580.html)
  - 循环依赖就是循环引用，就是两个或多个Bean相互之间的持有对方，比如CircleA引用CircleB，CircleB引用CircleC，CircleC引用CircleA，则它们最终反映为一个环。
  - Spring容器循环依赖包括构造器循环依赖和setter循环依赖
    - 构造器循环依赖。表示通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出`BeanCurrentlyInCreationException`异常表示循环依赖
    - setter循环依赖：表示通过setter注入方式构成的循环依赖，对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的Bean来完成的，而且只能解决单例作用域的Bean循环依赖
- Spring AOP的理解，各个术语，他们是怎么相互工作的？
  - [Spring AOP就是这么简单啦](https://segmentfault.com/a/1190000015018888)
  - 连接点(Join point) `能够被拦截的地方` Spring AOP是基于动态代理的，所以是方法拦截的。每个成员方法都可以称之为连接点
  - 切点(Poincut) `具体定位的连接点` 上面也说了，每个方法都可以称之为连接点，我们具体定位到某一个方法就成为切点
  - 增强/通知(Advice) 表示添加到切点的一段逻辑代码，并定位连接点的方位信息
    - 简单来说就定义了是干什么的，具体是在哪干
    - Spring AOP提供了5种Advice类型给我们：前置、后置、返回、异常、环绕给我们使用
  - 织入(Weaving)：将`增强/通知`添加到目标类的具体连接点上的过程
  - 引入/引介(Introduction) :`引入/引介`允许我们向现有的类添加新方法或属性。是一种特殊的增强
  - 切面(Aspect) 切面由`切点`和`增强/通知`组成，它既包括了横切逻辑的定义、也包括了连接点的定义
- Spring 如何保证 Controller 并发的安全？
  - 单例的，尽量不再Controller中使用成员变量
  - 需要使用变量的情况下，可以使用ThreadLocal变量
  - 特殊需求下可以使用原型模式（prototype）

### Netty
- BIO、NIO和AIO
- Netty 的各大组件
- Netty的线程模型
- TCP 粘包/拆包的原因及解决方法
- 了解哪几种序列化协议？包括使用场景和如何去选择
- Netty的零拷贝实现
- Netty的高性能表现在哪些方面

### 分布式相关
- Dubbo的底层实现原理和机制
- 描述一个服务从发布到被消费的详细过程
- 分布式系统怎么做服务治理
  - 超时控制
  - 服务降级
  - 负载均衡策略调整
  - 服务注册
  - 服务发现
  - 内置的熔断机制，避免整个分布式系统产生雪崩效应
- 接口的幂等性的概念
  - 以相同参数调用同一个接口多次，对系统内部产生的影响是一致的
- 消息中间件如何解决消息丢失问题
  - RocketMQ 本地事务表
  - 主从双写
- Dubbo的服务请求失败怎么处理
- 重连机制会不会造成错误
- 对分布式事务的理解
  - [深入理解分布式事务](http://blog.jobbole.com/108569/)
  - 简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性
  - 常见的分布式事务解决方案
    - 基于XA协议的两阶段提交 致命的缺点，那就是性能不理想
    - `消息事务+最终一致性` 消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败
- 如何实现负载均衡，有哪些算法可以实现？
  - Nginx反向代理
  - Spring cloud 用的客户端负载均衡
- Zookeeper的用途，选举的原理是什么？
  - 作为一个开源的分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作
  - 命名服务是指通过指定的名字来获取资源或者服务的地址，提供者的信息
  - 唯一编号 分布式系统中，经常需要给一个资源生成一个唯一的ID，在没有中心管理结点的情况下生成这个ID并不是一件很容易的事儿。zk就提供了这样一个命名服务，一般是使用create方法，创建一个自动编号的节点
  - 配置管理 主要用于多个结点共享配置，并且在配置发生更新时，利用zk可以让这些使用了这些配置的结点获得通知，进行重新加载等操作
  - 集群管理 主要有两个方面：一是集群选主，二是资源定位
  - 共享锁 实现起来和集群选主基本一致，都是创建一个自动编号的临时结点，然后watch父结点，判断自己是否是最小编号节点
- 数据的垂直拆分水平拆分
  - `垂直拆分` 是指数据表列的拆分，把一张列比较多的表拆分为多张表
    - 把不常用的字段单独放在一张表
    - 把text，blob等大字段拆分出来放在附表中
    - 经常组合查询的列放在一张表中
    - 垂直拆分更多时候就应该在数据表设计之初就执行的步骤，然后查询的时候用join关键起来即可
  - `水平拆分` 是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放
    - 通常情况下，我们使用ID取模的方式来进行表的拆分
- zookeeper原理和适用场景
  - [大白话讲Zookeeper能做什么？（一）：命名服务与配置管理](https://my.oschina.net/OHC1U9jZt/blog/1524613)
- zookeeper watch机制
  - Znode发生变化（Znode本身的增加，删除，修改，以及子Znode的变化）可以通过Watch机制通知到客户端
- redis/zk节点宕机如何处理
  - [redis集群节点宕机](https://www.cnblogs.com/dadonggg/p/8628735.html)
  - redis 一般有主从配置 切换从
  - Zookeeper本身也是集群啊，推荐配置不少于3个服务器。Zookeeper自身也要保证当一个节点宕机时，其他节点会继续提供服务
    - 如果是一个Follower宕机，没有关系啊，还有2台服务器提供访问，因为Zookeeper上的数据是有多个副本的，数据并不会丢失
    - 如果是一个Leader宕机，Zookeeper会选举出新的Leader
- 分布式集群下如何做到唯一序列号
  - 数据库自增长序列或字段
  - UUID
  - Redis生成ID
  - Twitter的snowflake算法
- 如何做一个分布式锁
- 用过哪些MQ，怎么用的，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗
- MQ系统的数据如何保证不丢失
- 列举出你能想到的数据库分库分表策略；分库分表后，如何解决全表查询的问题
- zookeeper的选举策略
- 全局ID

### 数据库
- 事务的ACID特性
  - 原子性（A）
  - 一致性（C）
  - 隔离性（I）
  - 持久性（D）
- mysql分页有什么优化
  - [mysql 大数据量分页优化](https://www.cnblogs.com/codeAB/p/6391607.html)
  - 在查询下一页时把上一页的行id作为参数传递给客户端程序
  - 延迟关联
- 悲观锁、乐观锁
- 组合索引，最左原则
  - 最左原则需要考虑到mysql查询优化器
- mysql 的表锁、行锁
- mysql 性能优化
- mysql的索引分类：B+，hash；什么情况用什么索引
  - [由 B-/B+树看 MySQL索引结构](https://segmentfault.com/a/1190000004690721)
- [事务的特性和隔离级别](https://yluoyu.github.io/summary/#/%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3)
  - 读未提交 `脏读`
  - 读已提交 `不可重复读`
  - 可重复读 mysql默认级别 存在`幻读`(查询没有，但插入报错场景)
  - 可序列化

### 缓存
- Redis用过哪些数据数据，以及Redis底层怎么实现
  - 字符串对象 STRING
  - 列表对象 LIST
  - 哈希对象 HASH
  - 集合对象 SET
  - 有序集合对象 ZSET
  - 底层数据结构不同 有整数、简单动态字符串、字典、双端链表、压缩列表、整数集合、跳跃表和字典
- Redis缓存穿透，缓存雪崩
  - 使用互斥锁
  - 异步构建缓存
- 如何使用Redis来实现分布式锁
  - [Redis分布式锁的正确实现方式](https://www.cnblogs.com/linjiqin/p/8003838.html)
  - setnx()
- Redis的并发竞争问题如何解决
  - [Redis的并发竞争问题的解决方案总结](https://www.cnblogs.com/shamo89/p/8385390.html)
  - Redis事务功能
  - 客户端针对key加分布式锁
- Redis持久化的几种方式，优缺点是什么，怎么实现的
  - [redis持久化的几种方式](https://www.cnblogs.com/chenliangcl/p/7240350.html)
  - RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化）Redis会将数据集的快照dump到`dump.rdb`文件中
  - AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）
- Redis的缓存失效策略
  - [Redis学习笔记--Redis数据过期策略详解](https://www.cnblogs.com/xuliangxing/p/7151812.html)
  - 3种过期策略,Redis采用的是`惰性删除+定期删除`
    - 定时删除 在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除
    - `惰性删除` key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null
    - 定期删除
- Redis集群，高可用，原理
- Redis缓存分片
- Redis的数据淘汰策略
  - [缓存淘汰策略](https://blog.csdn.net/lizhi_java/article/details/68953179?locationNum=1&fps=1)

### JVM
- 详细jvm内存模型
- 讲讲什么情况下回出现内存溢出，内存泄漏？
  - 申请内存容量的时候，系统无法给到你足够的内存容量大小
  - 向系统申请到了你想要的内存空间（new），但是使用完了之后却不归还（delete），结果你申请到的内存空间你自己也访问不到（也许你把地址搞丢了），系统也无法分配该空间给其他的程序。这就是一次泄漏
- 说说Java线程栈
- JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
  - 通过年龄计数器判断一个对象是否需要转移。对象每经过一个GC 仍然活着，年龄计数器加1。当年龄超过设定的值，则将其通过担保机制转移到老年代
  - 也可以动态判定，当Survivor 中 年龄相同的对象超半数，则年龄大于该年龄的对象转移到老年代，无需等待到达设置的最大年龄值
  - 大对象直接进入老年代
- JVM 出现 fullGC 很频繁，怎么去线上排查问题？
  - [Major GC和Full GC的区别是什么？触发条件呢](https://www.zhihu.com/question/41922036)
  - 通过参数`HeapDumpBeforeFullG`C与`HeapDumpAfterFullGC` 得到fg前后的heap dump
  - Dump文件分析 jvisualvm
  - `Young GC` eden区分配满的时候触发
  - Full GC触发条件
    - 调用System.gc时，系统建议执行Full GC，但是不必然执行
    - 老年代空间不足
    - 方法区空间不足
    - 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    - 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
- 类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式
  - [ClassLoader双亲委托与类加载隔离](https://zhuanlan.zhihu.com/p/31182000)
  - 自定义类加载器步骤
  - 好处：
    - 可以避免java类的重复加载
    - 可以避免用户自定义同路径类对于J2SE平台自己定义的核心API的破坏
    - 基于JVM标识每个类的唯一性需要与类加载器一同来判断，那么，通过我们自定义的类加载器加载的类，就能很灵活和方便的与其他甚至同名的类区分开来，进行隔离使用。大大增强了我们对类的使用
  - 双亲委派模型只是JVM规范要求，实际你自己实现的 ClassLoader尊不遵守这个规范完全按照自己的业务需求来定
  - 打破的方式-继承ClassLoader覆盖loadClass方法
  - JVM规范中，双亲委托模型并不是一个强制性的约束，而是java设计者推荐给开发者的类加载实现方式。在java的世界中大部分的类加载器都遵循这个模型。但到目前为止，该模型主要出现以下几次大规模"被破坏"的情况：
- 类的实例化顺序
  - 首先是父类的静态变量和静态代码块（看两者的书写顺序）
  - 第二执行子类的静态变量和静态代码块（看两者的书写顺序）
  - 第三执行父类的成员变量赋值
  - 第四执行父类类的构造代码块
  - 第五执行父类的构造方法（）
  - 执行子类的构造代码块
  - 第七执行子类的构造方法（）；
- JVM垃圾回收机制，何时触发MinorGC等操作
  - [垃圾回收算法与 JVM 垃圾回收器综述](https://zhuanlan.zhihu.com/p/28258571)
  - [一次CMS GC问题排查过程（理解原理+读懂GC日志）](http://iamzhongyong.iteye.com/blog/1989829)
- JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的
  - 默认 CMS + ParNew
- 各种回收器，各自优缺点，重点CMS、G1
  - 目前就老年代CMS回收器用了标记清除，其他老年代回收器都是标记压缩
  - 新生代
    - Serial GC `复制算法`
      - 它仅仅使用单线程进行垃圾回收
      - 它独占式的垃圾回收。在串行回收器进行垃圾回收时，Java 应用程序中的线程都需要暂停，等待垃圾回收的完成
      - 适合：实现相对简单，逻辑处理特别高效，且没有线程切换的开销，单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合
    - ParNew GC `复制算法`
      - 简单地将串行回收器多线程化
      - 适合：在并发能力比较强的 CPU 上，它产生的停顿时间要短于串行回收器
    - Parallel Scavenge GC `复制算法`
      - 吞吐量优先收集器
      - 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）
    - G1 收集器
  - 老年代 `标记-清理`
    - SerialOld `标记-整理`
    - ParallelOld `标记-整理`
      - 适合：吞吐量优先
    - CMS
      - 特点，就是用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停
      - 缺点：内存碎片
      - 需要更大的堆空间，CMS默认在老年代空间使用68%时候启动垃圾回收
      - 适合：要求服务器响应速度高的情况下，使用CMS非常合适
      - 步骤
        - 初始标记 这个阶段会`STW`
        - 并发标记
        - 并发预清理
        - 重新标记 `STW`
        - 并发清理
        - 并发重置
    - G1 收集器
- 各种回收算法
  - 分代回收算法 整体方案
    - 将内存区间根据对象的特点分成几块，根据 每块内存区间的特点，使用不同的回收算法，以提高垃圾回收的效率
    - 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2
    - 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )
  - 标记-清除 分两阶段 标记阶段和清除阶段
    - 优点：简单
    - 缺点：内存碎片
  - 复制算法 将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收
    - 优点：适用于存活数量较少时，效率高，而且没有内存碎片
    - 缺点：内存利用率不高，需要空出50%
  - 标记-压缩 标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化
    - 优点：没有内存碎片，也不需要相同的两块空间，性价比较高
    - 缺点：GC暂停的时间会增长
- OOM错误，stackoverflow错误，permgen space错误
